#include "Ring_buf.hpp"

// В этом конструкторе инициализируются три переменные:

// wr_idx: индекс записи, устанавливается в 0, что означает, 
// что следующая запись будет происходить в начале буфера.
// rd_idx: индекс чтения, также устанавливается в 0, 
// что означает, что чтение будет происходить с начала буфера.
// size: текущее количество элементов в буфере, 
// инициализируется нулем, так как буфер пуст.
Ring_buffer::Ring_buffer():wr_idx{0}, rd_idx{0}, size{0} {}


// Этот метод извлекает элемент из буфера:

// Сначала он сохраняет значение, которое находится по текущему индексу чтения (rd_idx), 
// в переменной tmp.
// Затем индекс чтения (rd_idx) увеличивается на 1, чтобы указать на следующий 
// элемент.
// Оператор %= используется для обеспечения цикличности индекса: если rd_idx достигает 
// CAPACITY, он сбрасывается на 0 (то есть возвращается к началу массива).
// Размер буфера уменьшается на 1, поскольку мы извлекли элемент.
// Метод возвращает значение, извлеченное из буфера (сохраненное в tmp).

uint8_t Ring_buffer::get(){
    uint8_t tmp = arr[rd_idx]; // Сохранение значения по индексу чтения
    rd_idx++; // Увеличиваем индекс чтения
    rd_idx %= CAPACITY; // Обеспечиваем циклический переход индекса
    size--; // Уменьшаем размер буфера
    return tmp; // Возвращаем извлеченное значение
}


// Этот метод добавляет элемент в буфер:

// Сначала проверяется, не полон ли буфер, вызывая метод not_full().
// Если буфер не полон, значение val записывается в массив arr по индексу записи (wr_idx).
// Индекс записи (wr_idx) увеличивается, и оператор %= обеспечивает цикличность индекса.
// Размер буфера увеличивается на 1, поскольку мы добавили элемент.

void Ring_buffer::put (uint8_t val){

    if(not_full()){    
    arr[wr_idx] = val;
    wr_idx %= CAPACITY;  // ===> a = a % b === a %= b Вычисление остатка от деления, совмещённое с присваиванием
    size++;
    }
}



// Этот метод проверяет, пуст ли буфер. Он возвращает true, если size равен 0, 
// и false в противном случае.

bool Ring_buffer::empty(){
    return (size == 0);

}



//Этот метод проверяет, не заполнен ли буфер. Он возвращает true, если текущее количество элементов меньше максимальной емкости (CAPACITY). 
// Обратите внимание, что условие должно быть size < CAPACITY,
// чтобы правильно проверять, есть ли место для добавления новых элементов.
bool Ring_buffer::not_full(){
    return (size<=CAPACITY);
}

bool Ring_buffer::full(){
    return (size == CAPACITY);
}